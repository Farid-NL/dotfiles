% git, changes

# Delete file(s) and stage the removal(s) for commit
git rm <files>

# Untrack file(s)
git rm --cached <files>

# Move file and stage the movement for commit
git mv <file> <new_file_path>

$ new_file_path: find * -type d -not -iwholename '*.git*' --- --preview 'eza -TD --icons=auto'
$ file: git ls-files --- --preview 'eza -T --icons=auto'
$ files: git ls-files --- --multi --expand



% git, diff
@ git, changes

# View changes of a file between commits
git diff <commit_hash1> <commit_hash2> -- <file>

# View changes in the staging area
git diff --staged

$ commit_hash1: git log --format=format:%h --- --preview 'git lg'
$ commit_hash2: git log --format=format:%h --- --preview 'git lg'



% git, branch
@ git, remote
@ git, restore

# Create new branch based on current branch
git branch <branch_name>

# Create new branch based on a specific commit
git branch <branch_name> <commit_hash>

# Rename branch
git branch -m <branch> <new_name>

# Create and change/switch to a new branch
git switch -c <branch_name>

# Change/switch branch
git switch <branch>

# Delete a local branch
git branch -d <branch>

# Delete a local branch forcefully
git branch -D <branch>

# Delete a remote branch
git push <remote_name> --delete <branch_name>

$ branch: git branch --format='%(refname:short)'



% git, remote

# Add remote
git remote add <remote_name> <remote_url>

# Remove remote
git remote remove <remote_name>

# Change remote name
git remote rename <old_remote_name> <new_remote_name>

# Change URL of a remote
git remote set-url <remote_name> <new_remote_url>

# Add URL to a remote
git remote set-url --add <remote_name> <remote_url>

# Delete URL of a remote
git remote set-url --delete <remote_name> <remote_url>

$ remote_name: git remote
$ old_remote_name: git remote



% git, edit

# Change last commit contents and/or message
git commit --amend -m "<commit_msg>"

# Change last commit contents but not the commit message
git commit --amend --no-edit

# Change author while committing
git commit -m "<commit_msg>" --author="<author_name> <<author_email>>"

# Change author of the last commit
git commit --amend --author="<author_name> <<author_email>>" --no-edit



;;;; Stash ;;;;
; TODO: https://git-scm.com/docs/git-stash



% git, restore
@ git, changes

# Discard changes in working directory
git restore <files>

# Restore file to a specific point
git restore -s <reference> <file>

$ reference: git branch --format='%(refname:short)';git tag --format='%(refname:short)';git log --format=format:%h --- --preview 'git lg'



% git, reset

# Remove commits from local repository (stage changes)
git reset --soft <commit_hash>

# Remove commits from local repository (unstage changes)
git reset <commit_hash>

# Remove commits from local repository (discard changes)
git reset --hard <commit_hash>

# Recover from a git action
git reset <reflog_head>

$ commit_hash: git log --format=format:%h --- --preview 'git lg'
$ reflog_head: git reflog --format=format:%gd --- --preview 'git reflog'





;;;; Revert ;;;;
; TODO: https://git-scm.com/docs/git-stash



;;;; Merge ;;;;
; TODO: https://git-scm.com/docs/git-merge



% git, rebase
@ git, branch

# Rebase current branch on top of another one
git rebase <new_base>

# Rebase a branch on top of another one
git rebase <new_base> <branch>

# Rebase current branch onto a new base
git rebase --onto <new_base> <old_base>

# Rebase a range of commits in the current branch onto a new base
git rebase --onto <new_base> <old_base> <up_to>

; TODO: https://git-scm.com/docs/git-rebase#Documentation/git-rebase.txt---interactive

$ new_base: git branch --format='%(refname:short)';git tag --format='%(refname:short)';git log --format=format:%h --- --preview 'git lg'
$ old_base: git branch --format='%(refname:short)';git tag --format='%(refname:short)';git log --format=format:%h --- --preview 'git lg'
$ up_to: git log --format=format:%h --- --preview 'git lg'



% git, apply

# Create patch
git diff > <file_name>.patch

# Apply patch to the working directory
git apply <patch_path>

# Apply patch to the working directory and staging area
git apply <patch_path> --index

# Apply patch only to the staging area
git apply <patch_path> --cached

# Check patch before applying (dry run)
git apply <patch_path> --check

# See file statistics before applying the patch
git apply <patch_path> --stat

# Fix trailing whitespace errors
git apply <patch_path> --whitespace=fix

# Apply patch ignoring additions (just removals)
git apply <patch_path> --no-add

# Apply patch excluding files matching the given path pattern
git apply <patch_path> --exclude=<path_pattern>

$ path_pattern: git ls-files --- --preview 'eza -T --icons=auto'
$ patch_path: ls | egrep '.diff$|.patch$'



% git, cherry-pick

# Apply the changes introduced by some existing commits
git cherry-pick <commit_hash>

# Edit the commit message prior to cherry pick.
git cherry-pick <commit_hash> --edit

# Stage the changes introduced by some existing commits
git cherry-pick <commit_hash> --no-commit

$ commit_hash: git log --format=format:%h --- --multi --expand --preview 'git lg'



% git, hooks

# Skip `pre-commit`, `pre-merge-commit`, `commit-msg`, `p4-changelist` and `p4-pre-submit` hooks
git commit --no-verify
