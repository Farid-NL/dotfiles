% git, changes

# Delete file(s) and stage the removal(s) for commit
git rm <files>

# Untrack file(s)
git rm --cached <files>

# Move file and stage the movement for commit
git mv <file> <new_file_path>

$ new_file_path: find * -type d -not -iwholename '*.git*' --- --preview 'eza -TD --color=always --icons=always'
$ file: git ls-files --- --preview 'eza -T --color=always --icons=always'
$ files: git ls-files --- --multi --expand



% git, diff
@ git, changes

# View changes of a file between commits
git diff <commit_hash1> <commit_hash2> -- <file>

# View changes in the staging area
git diff --staged

$ commit_hash1: git log --format=%h --- --preview 'git lg --color=always'
$ commit_hash2: git log --format=%h --- --preview 'git lg --color=always'



% git, branch
@ git, remote
@ git, restore

# Create new branch based on current branch
git branch <branch_name>

# Create new branch based on a specific commit
git branch <branch_name> <commit_hash>

# Rename branch
git branch -m <branch> <new_name>

# Create and change/switch to a new branch
git switch -c <branch_name>

# Change/switch branch
git switch <branch>

# Delete a local branch
git branch -d <branch>

# Delete a local branch forcefully
git branch -D <branch>

# Delete a remote branch
git push <remote_name> --delete <branch_name>

$ branch: git branch --format='%(refname:short)'



% git, remote

# List/Show remotes with their respective url
git remote -v

# Add remote
git remote add <remote_name> <remote_url>

# Remove remote
git remote remove <remote_name>

# Change remote name
git remote rename <old_remote_name> <new_remote_name>

# Change URL of a remote
git remote set-url <remote_name> <new_remote_url>

# Add URL to a remote
git remote set-url --add <remote_name> <remote_url>

# Delete URL of a remote
git remote set-url --delete <remote_name> <remote_url>

$ remote_name: git remote
$ old_remote_name: git remote



% git, edit

# Change last commit contents and/or message
git commit --amend -m "<commit_msg>"

# Change last commit contents but not the commit message
git commit --amend --no-edit

# Change author while committing
git commit -m "<commit_msg>" --author="<author_name> <<author_email>>"

# Change author of the last commit
git commit --amend --author="<author_name> <<author_email>>" --no-edit



% git, stash

# List the stash entries that you currently have
git stash list

# Save local modifications to a new stash entry
git stash push

# Save local modifications to a new stash entry with a description
git stash push -m <description>

# Save specific local modifications to a new stash entry
git stash push -p

# Apply and remove the last stash entry
git stash pop

# Apply and remove a specific stash entry
git stash pop --index <stash_index>

# Apply the last stash entry
git stash apply

# Apply a specific stash entry
git stash apply --index <stash_index>

# Show diff of a specific stash entry
git stash show -p <stash_index>

# Create branch from a specific stash entry
git stash branch <branch_name> <stash_index>

# Remove a specific stash entry
git stash drop <stash_index>

# Remove all stash entries
git stash clear

$ stash_index: git stash list --format=%gd --- --expand --preview "git stash list --format='%gd %s (%cr)'"



% git, restore
@ git, changes

# Discard changes in working directory
git restore <files>

# Restore file to a specific point
git restore -s <reference> <file>

$ reference: git branch --format='%(refname:short)';git tag --format='%(refname:short)';git log --format=%h --- --preview 'git lg --color=always'



% git, reset

# Remove commits from local repository (stage changes)
git reset --soft <commit_hash>

# Remove commits from local repository (unstage changes)
git reset <commit_hash>

# Remove commits from local repository (discard changes)
git reset --hard <commit_hash>

# Recover from a git action
git reset <reflog_head>

$ commit_hash: git log --format=%h --- --preview 'git lg --color=always'
$ reflog_head: git reflog --format=%gd --- --preview 'git reflog'



% git, revert
@ git, cherry-pick

# Revert a (range of) commit(s)
git revert <commit_hash>

# Revert a (range of) commit(s) without specifying a commit message
git revert <commit_hash> --no-edit

# Revert a (range of) commit(s) without creating commits (staging them)
git revert <commit_hash> --no-commit



% git, merge
@ git, branch

# Merge a branch into the current one
git merge <branch>

# Merge a branch into the current one creating a merge commit
git merge <branch> --no-ff

# Merge a branch into the current one as a fast-forward
git merge <branch> --ff-only



% git, rebase
@ git, branch
@ git, reset

# Rebase current branch on top of another one
git rebase <new_base>

# Rebase a branch on top of another one
git rebase <new_base> <branch>

# Rebase current branch onto a new base
git rebase --onto <new_base> <old_base>

# Rebase a range of commits in the current branch onto a new base
git rebase --onto <new_base> <old_base> <up_to>

# Rebase multiple commits interactively
git rebase --interactive <commit_hash>

$ new_base: git branch --format='%(refname:short)';git tag --format='%(refname:short)';git log --format=%h --- --preview 'git lg --color=always'
$ old_base: git branch --format='%(refname:short)';git tag --format='%(refname:short)';git log --format=%h --- --preview 'git lg --color=always'
$ up_to: git log --format=%h --- --preview 'git lg --color=always'



% git, apply

# Create patch
git diff > <file_name>.patch

# Apply patch to the working directory
git apply <patch_path>

# Apply patch to the working directory and staging area
git apply <patch_path> --index

# Apply patch only to the staging area
git apply <patch_path> --cached

# Check patch before applying (dry run)
git apply <patch_path> --check

# See file statistics before applying the patch
git apply <patch_path> --stat

# Fix trailing whitespace errors
git apply <patch_path> --whitespace=fix

# Apply patch ignoring additions (just removals)
git apply <patch_path> --no-add

# Apply patch excluding files matching the given path pattern
git apply <patch_path> --exclude=<path_pattern>

$ path_pattern: git ls-files --- --preview 'eza -T --color=always --icons=always'
$ patch_path: ls | egrep '.diff$|.patch$'



% git, cherry-pick

# Apply the changes introduced by some existing commits
git cherry-pick <commit_hash>

# Edit the commit message prior to cherry pick.
git cherry-pick <commit_hash> --edit

# Stage the changes introduced by some existing commits
git cherry-pick <commit_hash> --no-commit

$ commit_hash: git log --format=%h --- --multi --expand --preview 'git lg --color=always'



% git, hooks

# Skip `pre-commit`, `pre-merge-commit`, `commit-msg`, `p4-changelist` and `p4-pre-submit` hooks
git commit --no-verify
